# Fast API exam
Create an API to display / add / delete Multiple Choice Questions in a csv file.

## Background
For this evaluation, we will put ourselves in the shoes of a company that creates questionnaires via a smartphone or web browser application. To simplify the architecture of these different products, the company wants to set up an API. The purpose of this API is to query a database to return a series of questions.


Therefore, the objective of this evaluation is to create this API.

## The data
Our database is represented by a csv file available at this address.

You can download the dataset on your machine with this command:

`wget https://dst-de.s3.eu-west-3.amazonaws.com/fastapi_en/questions_en.xlsx`                                                                 
â€ƒ You may need to install the following package to read excel files: openpyxl
It contains the following fields:

- question: the title of the question
- subject : the category of the question
- correct : the list of correct answers
- use: the type of MCQ for which this question is used
- answerA : answer A
- answerB : answer B
- answerC : answer C
- answerD : the answer D (if it exists)
Explore this dataset to understand this data

## The API
On the application or web browser, the user must be able to choose a test type (use) as well as one or more categories (subject). Moreover, the application can produce MCQs of 5, 10 or 20 questions. The API must therefore be able to return this number of questions. As the application must be able to generate many MCQs, the questions must be returned in a random order: thus, a request with the same parameters can return different questions.

As users must have created an account, we need to be able to verify their credentials. For now the API uses basic authentication, based on username and password: the string containing Basic username:password will have to be passed in the Authorization header (in theory, this string should be encoded but to simplify the exercise, we can choose not to encode it)

For the identifiers, we can use the following dictionary :
```
{
    "alice": "wonderland",
    "bob": "builder",
    "clementine": "mandarine"
}
```
The API will also need to implement an endpoint to verify that the API is functional. Another feature should allow an admin user whose password is 4dm1N to create a new question.

Finally, it should be widely documented and should return errors when it is called incorrectly.

## Outputs
Expected output is one or more Python files containing the API code and a file containing the command to test the API. You can also provide a requirements.txt file listing the libraries to install. Finally, you can provide a document explaining the architecture choices made.

Launch with :	`uvicorn src.main:api --reload`

files:
- 	./requirements.txt	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modules to install
- 	./src/main.py		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;API code file
- 	./src/test_api.py	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;launch to test the API
- 	./questions.csv		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;csv file containing the MCQ question list
- 	./new_mcq.csv		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file generated by the /mcq endpoint

## Solution

First of all, I had to use httptools 0.6.4 because otherwise, I got the "failed building wheel" error during installation (OSX).

I used the user DB structure from the courses because it resembles a real database more.<br>
Apart from the encrypted passwords, I could perform an MD5 hash comparison for authentication.<br>
Of course, the admin is stored among the users, with ID 0 (maybe a bit too obvious :laughing:).

I preferred to work with a basemodel to simplify things. Less code is (mostly) better.

I could have developed the error handling more because if a category doesn't match a type, we don't know what went wrong. But the user should have the list in front of them. Alternatively, we could show them which types contain which categories. However, this is not really related to the API's functionality itself; it's just queries to add and modify the text in the documentation accordingly.

I used a mix of requests and subprocess, just to test both.




